parser grammar CSVParser;

@header {
	using System;
}

options { tokenVocab = CSVLexer ;}

compileUnit
locals [int i=0]
	//       label	syntax_symbol            action
	//		 |      |						 |
	//		 |		|						 increase i in every row recognition
	//		 |		rows: each match creates a new rowcontext object
	//       |      $hdr: is an hdrcontext object associate with hdr symbol in the rule
	//       rows is label associated to an array of the rowcontext objects recognized by the rule
	:	hdr (rows+=row[$hdr.text.Split(',')] {$i++;})* {
	//					  after the rule is matched i refers to the number of rows of values
		Console.WriteLine($i+ " rows");
		foreach ( RowContext r in $rows ){
			Console.WriteLine("row token interval: "+ r.SourceInterval);
		}
	}
	;
	//											$text refers to the text matched for the current rule
	//											in this case it represents the header row
hdr : row[null] {Console.WriteLine("header: \""+ $text.Trim()+"\"");};


//input parameters				return values
//|								|
//row rule takes an array of    | strings as a parameter representing the column headers
//							    returns a dictionary with the values associated to the corresponding column
row[string[] columns] returns [Dictionary<string,string> values] 
// local variables can be accessed only from actions within the rule
locals [int col=0]
// initial actions are executed before any matching takes place
@init {
	$values = new Dictionary<string,string>();
}
// final actions are executed after matching of the rule takes place
@after {
	if ( $values != null && $values.Count >0 ){
		foreach ( KeyValuePair<string, string> s in $values ){
			Console.WriteLine("key="+s.Key +" value ="+ s.Value);	
		}		
	}
}
     :   field {
//			if columns != null it means that parsing is at the value rows and
//			hence values can be associated to the header of the corresponding row
			if ( $columns != null ){
				$values[$columns[$col++].Trim()] = $field.text.Trim();
			}
		}
		(COMMA field {
//			if columns != null it means that parsing is at the value rows and
//			hence values can be associated to the header of the corresponding row
			if ( $columns != null ){
				$values[$columns[$col++].Trim()] = $field.text.Trim();
			}
		}		
		)* SR? NEWLINE
	  | field {
//			if columns != null it means that parsing is at the value rows and
//			hence values can be associated to the header of the corresponding row
			if ( $columns != null ){
				$values[$columns[$col++].Trim()] = $field.text.Trim();
			}
		} (COMMA field {
//			if columns != null it means that parsing is at the value rows and
//			hence values can be associated to the header of the corresponding row
			if ( $columns != null ){
				$values[$columns[$col++].Trim()] = $field.text.Trim();
			}
		})* SR? EOF
	  | SR? NEWLINE
	;

field : TEXT
	  | STRING	  
		;
